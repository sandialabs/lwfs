/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */


#include <math.h>
#include <assert.h>
#include <argp.h>
#include <getopt.h>
#include <signal.h>
#include <unistd.h>
#include <time.h>
#include <mpi.h>

#include "support/logger/logger.h"
#include "support/timer/timer.h"

#include "common/types/types.h"
#include "common/rpc_common/lwfs_ptls.h"
#include "common/rpc_common/rpc_common.h"
#include "common/rpc_common/rpc_xdr.h"

#include "client/rpc_client/rpc_client.h"

/*`
#include "rpc/rpc_srvr.h"
*/

#include "xfer.h"

log_level xfer_debug_level = LOG_UNDEFINED;

const int LWFS_XFER_1_ID = 1;
const int LWFS_XFER_2_ID = 2;

enum {
	XFER_ARGS_BLK = 0,
	XFER_ARGS_NOBLK,
	XFER_DATA_BLK,
	XFER_DATA_NOBLK
};






/* ----------------- COMMAND-LINE OPTIONS --------------- */

const char *argp_program_version = "$Revision$"; 
const char *argp_program_bug_address = "<raoldfi@sandia.gov>"; 

static char doc[] = "Test the LWFS storage service";
static char args_doc[] = ""; 

/**
 * @brief Command line arguments for testing the storage service. 
 */
struct arguments {

	/** @brief The debug level. */
	int verbose; 

	/** @brief the size of the input/output buffer to use for tests. */
	int len; 

	/** @brief The number of experiments to run. */
	int count; 

	/** @brief The number of requests for an async experiment. */
	int num_reqs; 

	/** @brief Type of experiment. */
	int type; 

	/** @brief Result file name. */
	char *result_file; 

	/** @brief Result file mode. */
	char *result_file_mode; 

	/** @brief Name of the remote server. */
	char *server_name; 

	/** @brief Process ID of the remote server. */
	lwfs_remote_pid server; 
}; 

static int print_args(FILE *fp, const char *prefix, struct arguments *args) 
{
	time_t now; 
	int myrank; 

	MPI_Comm_rank(MPI_COMM_WORLD, &myrank);

	if (myrank == 0) {
		/* get the current time */
		now = time(NULL);

		fprintf(fp, "%s -----------------------------------\n", prefix);
		fprintf(fp, "%s \tMeasure LWFS RPC throughput", prefix);

		switch (args->type) {
			case XFER_ARGS_BLK:
				fprintf(fp, " (blocking calls, array in args)\n");
				break;
			case XFER_ARGS_NOBLK:
				fprintf(fp, " (async calls, array in args)\n");
				break;
			case XFER_DATA_BLK:
				fprintf(fp, " (blocking calls, array in data portal)\n");
				break;
			case XFER_DATA_NOBLK:
				fprintf(fp, " (async calls, array in data portal)\n");
				break;
			default:
				fprintf(fp, " (undefined type)\n");
				break;
		}

		fprintf(fp, "%s \t%s", prefix, asctime(localtime(&now)));


		fprintf(fp, "%s ------------  ARGUMENTS -----------\n", prefix); 
		fprintf(fp, "%s \t--verbose = %d\n", prefix, args->verbose);
		fprintf(fp, "%s \t--len = %d\n", prefix, args->len);
		fprintf(fp, "%s \t--count = %d\n", prefix, args->count);
		fprintf(fp, "%s \t--num-reqs = %d\n", prefix, args->num_reqs);
		fprintf(fp, "%s \t--result-file = \"%s\"\n", prefix, args->result_file);
		fprintf(fp, "%s \t--result-file_mode = \"%s\"\n", prefix, args->result_file_mode);
		fprintf(fp, "%s \t--server-name = \"%s\"\n", prefix, args->server_name);
		fprintf(fp, "%s \t--server-nid = %u\n", prefix, args->server.nid);
		fprintf(fp, "%s \t--server-pid = %u\n", prefix, args->server.pid);
		fprintf(fp, "%s -----------------------------------\n", prefix);

		fflush(fp);
	}
	return 0;
}


static struct argp_option options[] = {
	{"verbose",    1, "<val>", 0, "Debug level"},
	{"len",    2, "<val>", 0, "number of array elements to send for each exp"},
	{"count",      3, "<val>", 0, "Number of experiments to run"},
	{"type",      4, "<val>", 0, "Type of experiment"},
	{"num-reqs",      5, "<val>", 0, "Number of requests in an async experiment"},
	{"server-nid",      10, "<val>", 0, "Portals NID of the remote server."},
	{"server-pid",      11, "<val>", 0, "Portals PID of the remote server."},
	{"server-index",    12, "<val>", 0, "Portals index where the server expects reqs."},
	{"server-name",    13, "<val>", 0, "Hostname of the server."},
	{"result-file",    14, "<val>", 0, "File for results."},
	{"result-file-mode",    15, "<val>", 0, "Mode for the result file."},
	{ 0 }
};

/** 
 * @brief Parse a command-line argument. 
 * 
 * This function is called by the argp library. 
 */
static error_t parse_opt(
		int key, 
		char *arg, 
		struct argp_state *state)
{
	/* get the input arguments from argp_parse, which points to 
	 * our arguments structure */
	struct arguments *arguments = state->input; 

	switch (key) {

		case 1: /* verbose */
			arguments->verbose = atoi(arg);
			break;

		case 2: /* len */
			arguments->len = atoi(arg);
			break;

		case 3: /* count */
			arguments->count = atoi(arg);
			break;

		case 4: /* type */
			arguments->type = atoi(arg);
			break;

		case 5: /* num-reqs */
			arguments->num_reqs = atoi(arg);
			break;
			
		case 10: /* nid */
			arguments->server.nid = (lwfs_nid)atoll(arg);
			break;

		case 11: /* pid */
			arguments->server.pid = (lwfs_pid)atoll(arg);
			break;

		case 13: /* server-name */
			arguments->server_name = arg;
			break;

		case 14: /* result-file */
			arguments->result_file = arg;
			break;

		case 15: /* result-file-mode */
			arguments->result_file_mode = arg;
			break;



		case ARGP_KEY_ARG:
			/* we expect only one argument */
			if (state->arg_num >= 0) {
				argp_usage(state);
			}
			//arguments->args[state->arg_num] = arg; 
			break; 

		case ARGP_KEY_END:
			if (state->arg_num < 0)
				argp_usage(state);
			break;

		default:
			return ARGP_ERR_UNKNOWN; 
	}

	return 0;
}

static struct argp argp = {options, parse_opt, args_doc, doc}; 


void output_stats(
		FILE *result_fp, 
		struct arguments *args, 
		double t_total)
{
	double t_total_max = t_total;
	double t_total_min = t_total;
	double t_total_sum = t_total;
    static int first = 1; 
	int total_reqs = args->num_reqs; 
	int myrank=0, np=1; 

	MPI_Comm_size(MPI_COMM_WORLD, &np);
	MPI_Comm_rank(MPI_COMM_WORLD, &myrank);

	/* gather stats across participating nodes */
	MPI_Reduce(&args->num_reqs, &total_reqs, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);

	MPI_Reduce(&t_total, &t_total_min, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);
	MPI_Reduce(&t_total, &t_total_max, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);
	MPI_Reduce(&t_total, &t_total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);

	if (myrank == 0) {

		double t_total_avg = t_total_sum/np; 
		double nbytes = total_reqs*(sizeof(int) + (args->len+1)*sizeof(data_t)); 

		if (first) {
			time_t rawtime; 
			time(&rawtime); 

			fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
			fprintf(result_fp, "%s lwfs-xfer-client\n", "%");
			fprintf(result_fp, "%s %s", "%", ctime(&rawtime));
			fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
			fprintf(result_fp, "%s column   description\n", "%");
			fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
			fprintf(result_fp, "%s   0     number of clients\n", "%");
			fprintf(result_fp, "%s   1     total ops\n","%");
			fprintf(result_fp, "%s   2     data structures/op\n", "%");
			fprintf(result_fp, "%s   3     aggregate bytes\n","%");
			fprintf(result_fp, "%s   4     min time (sec)\n","%");
			fprintf(result_fp, "%s   5     max time (sec)\n","%");
			fprintf(result_fp, "%s   6     avg time (sec)\n","%");
			fprintf(result_fp, "%s   7     min throughput (MB/sec)\n","%");
			fprintf(result_fp, "%s   8     max throughput (MB/sec)\n","%");
			fprintf(result_fp, "%s   9     avg throughput (MB/sec)\n","%");
			fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
			first = 0; 
		}

		/* print the row */
		fprintf(result_fp, "%04d   ", np);    
		fprintf(result_fp, "%09d   ", total_reqs); 
		fprintf(result_fp, "%09d   ", args->len);    
		fprintf(result_fp, "%1.6e  ", nbytes); 
		fprintf(result_fp, "%1.6e  ", t_total_min); 
		fprintf(result_fp, "%1.6e  ", t_total_max); 
		fprintf(result_fp, "%1.6e  ", t_total_avg); 
		fprintf(result_fp, "%1.6e  ", nbytes/(t_total_max*1024*1024)); 
		fprintf(result_fp, "%1.6e  ", nbytes/(t_total_min*1024*1024)); 
		fprintf(result_fp, "%1.6e\n", nbytes/(t_total_avg*1024*1024)); 
		fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
		fflush(result_fp);
	}
}

int verify_result(int len, data_t *result)
{
	if (result->int_val != (int)(len-1)) {
		log_error(xfer_debug_level, "wrong int result: "
				"expected %d, got %d", 
				(int)(len-1), result->int_val);
		return LWFS_ERR_RPC; 
	}; 
	if (result->float_val != (float)(len-1)) {
		log_error(xfer_debug_level, "wrong float result: "
				"expected %f, got %f", 
				(float)(len-1), result->float_val);
		return LWFS_ERR_RPC; 
	}; 
	if (result->double_val != (double)(len-1)) {
		log_error(xfer_debug_level, "wrong double result: "
				"expected %g, got %g", 
				(double)(len-1), result->double_val);
		return LWFS_ERR_RPC; 
	}; 

	return LWFS_OK;
}



int xfer_1_clnt(
	const lwfs_service *svc, 
	const data_array_t *array, 
	data_t *result, 
	lwfs_request *req)
{
	int rc = LWFS_OK;
	xfer_1_args args; 
	int xdrsizeof_args; 
	int sizeof_args; 
	int sizeof_header; 
	int xdrsizeof_header; 
	lwfs_request_header hdr; 
	lwfs_opcode opcode = 1;


	/* initialize the arguments */
	memset(&args, 0, sizeof(xfer_1_args));
	memset(&hdr, 0, sizeof(lwfs_request_header));

	args.array.data_array_t_len = array->data_array_t_len; 
	args.array.data_array_t_val = array->data_array_t_val; 

	xdrsizeof_args= xdr_sizeof((xdrproc_t)&xdr_xfer_1_args, &args); 
	sizeof_args= sizeof(xfer_1_args); 

	xdrsizeof_header = xdr_sizeof((xdrproc_t)&xdr_lwfs_request_header, &hdr);
	sizeof_header = sizeof(hdr); 


	/* call the remote methods */
	rc = lwfs_call_rpc(svc, opcode, &args, NULL, 0, result, req); 
	if (rc != LWFS_OK) {
		log_error(xfer_debug_level, "unable to call xfer_1: %s",
			lwfs_err_str(rc));
	}

	return rc; 
}

int xfer_1_clnt_blk(
	const lwfs_service *svc, 
	const data_array_t *array, 
	data_t *result)
{
	int rc = LWFS_OK;
	int rc2 = LWFS_OK;
	lwfs_request req; 
	int len = array->data_array_t_len; 

	/* call the async function */
	rc = xfer_1_clnt(svc, array, result, &req);
	if (rc != LWFS_OK) {
		log_error(xfer_debug_level, "unable to call async method: %s",
				lwfs_err_str(rc));
		return rc; 
	}

	/* wait for completion */
	rc2 = lwfs_wait(&req, &rc);
	if (rc2 != LWFS_OK) {
		log_error(xfer_debug_level, "failed waiting for request: %s",
				lwfs_err_str(rc));
		return rc2; 
	}

	if (rc != LWFS_OK) {
		log_error(xfer_debug_level, "remote method failed: %s",
				lwfs_err_str(rc));
		return rc; 
	}

	/* verify the result */
	rc = verify_result(len, result); 
	if (rc != LWFS_OK) {
		log_error(xfer_debug_level, "invalid result");
		return rc; 
	}

	return rc; 

}

int xfer_2_clnt(
	const lwfs_service *svc, 
	const data_array_t *array, 
	data_t *result, 
	lwfs_request *req)
{
    int rc = LWFS_OK;
    xfer_2_args args; 
    int nbytes; 
	lwfs_opcode opcode=2;

    /* the buffer to send to the server */
    const data_t *buf = array->data_array_t_val; 

    /* the only argument to send is the size of the array */
    args.len = array->data_array_t_len; 

    /* calculate the number of bytes in the buffer */
    nbytes = args.len*sizeof(data_t); 

    /* call the remote methods (send buffer using the data portal) */
    rc = lwfs_call_rpc(svc, opcode,  &args, (char *)buf, nbytes, result, req); 
    if (rc != LWFS_OK) {
        log_error(xfer_debug_level, "unable to call xfer_1: %s",
                lwfs_err_str(rc));
    }

    return rc; 
}

int xfer_2_clnt_blk(
	const lwfs_service *svc, 
	const data_array_t *array, 
	data_t *result)
{
	int rc = LWFS_OK;
	int rc2 = LWFS_OK;
	lwfs_request req; 
	int len = array->data_array_t_len; 

	/* call the async function */
	rc = xfer_2_clnt(svc, array, result, &req);
	if (rc != LWFS_OK) {
		log_error(xfer_debug_level, "unable to call async method: %s",
			lwfs_err_str(rc));
		return rc; 
	}

	/* wait for completion */
	rc2 = lwfs_wait(&req, &rc);
	if (rc2 != LWFS_OK) {
		log_error(xfer_debug_level, "failed waiting for request: %s",
			lwfs_err_str(rc));
		return rc2; 
	}

	if (rc != LWFS_OK) {
		log_error(xfer_debug_level, "remote method failed: %s",
			lwfs_err_str(rc));
		return rc; 
	}

	/* verify the result */
	rc = verify_result(len, result); 
	if (rc != LWFS_OK) {
		log_error(xfer_debug_level, "invalid result");
		return rc; 
	}


	return rc; 

}




int
main (int argc, char *argv[])
{
	int rc; 
	int i,j; 
	struct arguments args; 
	double time; 
	lwfs_service xfer_svc; 
	data_array_t array; 
	double start_time; 
	data_t result; 
	FILE *result_fp = stdout;
	lwfs_request *reqs;   /* the array of requests (for async experiments) */
	data_t *results;      /* the array of results (for async experiments) */

	/* default values for the arguments */
	args.verbose = 6; 
	args.count = 3; 
	args.len = 1;
	args.num_reqs = 2; 
	args.server.nid  = 0; 
	args.server.pid  = 122; 
	args.type = XFER_ARGS_BLK;
	args.server_name = NULL;
	args.result_file = NULL;
	args.result_file_mode = "w";

	/* unique to each process */
	int num_reqs; 
	int myrank=0, np; 

	MPI_Init(&argc, &argv); 
	MPI_Comm_size(MPI_COMM_WORLD, &np);
	MPI_Comm_rank(MPI_COMM_WORLD, &myrank);

	if (myrank == 0) {
		argp_parse(&argp, argc, argv, 0, 0, &args); 
	}

	/* send the args to everyone else */
	MPI_Bcast(&args, sizeof(struct arguments), MPI_BYTE, 
				0, MPI_COMM_WORLD);
	
	/* initialize logger */
	logger_set_file(stdout); 
	if (args.verbose == 0)   {
		logger_set_default_level(LOG_OFF); 
	} else if (args.verbose > 5)   {
		logger_set_default_level(LOG_ALL); 
	} else   {
		logger_set_default_level(args.verbose - LOG_OFF); 
	}

	/* open the result file */
	if (myrank == 0) {
		if (args.result_file != NULL) {
			result_fp = fopen(args.result_file, args.result_file_mode);
			if (result_fp == NULL) {
				log_warn(xfer_debug_level, 
						"invalid result file:"
						"defaults to stdout");
				result_fp = stdout; 
			}
		}
	}

	/* initialize LWFS RPC */
	lwfs_ptl_init(PTL_IFACE_DEFAULT, myrank+args.server.pid);
	lwfs_rpc_init(LWFS_RPC_PTL, LWFS_RPC_XDR);

	/* If the user did not specify a nid, assume one */
	if ((args.server.nid == 0) && (args.server_name == NULL)) {
		/* assume localhost */
		args.server_name = "localhost";
		/*args.server.nid = lwfs_getnidbyname(args.server_name); */
	}
	if ((args.server.nid == 0) && (args.server_name != NULL)) {
		/* get nid from hostname */
		/*args.server.nid = lwfs_getnidbyname(args.server_name);*/
	}

	else if ((args.server.nid != 0) && (args.server_name == NULL)) {
		/* get hostname from nid */
		/*args.server_name = lwfs_getnamebynid(args.server.nid);*/
	}

	else if ((args.server.nid != 0) && (args.server_name != NULL)) {
		/* use the nid anyway */
		/*args.server_name = lwfs_getnamebynid(args.server.nid);*/
	}

	print_args(result_fp, "%", &args); 

	/* register the XDR encoding functions */
	lwfs_register_xdr_encoding(1,
		(xdrproc_t)&xdr_xfer_1_args,
		(xdrproc_t)NULL,
		(xdrproc_t)&xdr_data_t);

	lwfs_register_xdr_encoding(2,
		(xdrproc_t)&xdr_xfer_2_args,
		(xdrproc_t)NULL,
		(xdrproc_t)&xdr_data_t);


	/* get the service description from the server */
	if (myrank == 0) {
		rc = lwfs_get_service(args.server, &xfer_svc); 
		if (rc != LWFS_OK) {
			log_error(xfer_debug_level, "could not get svc description: %s",
					lwfs_err_str(rc));
			return rc; 
		}
	}
	/* send the args to everyone else */
	MPI_Bcast(&xfer_svc, sizeof(lwfs_service), MPI_BYTE, 
				0, MPI_COMM_WORLD);


	/* divide the requests among the processors */
	num_reqs = args.num_reqs/np; 
	if (myrank < (args.num_reqs % np)) {
		num_reqs++;
	}

	MPI_Barrier(MPI_COMM_WORLD);
	//fprintf(stderr, "%d: reqs=%d, np=%d, reqs/np=%d, (reqs mod np)=%d\n",
	//		myrank, args.num_reqs, np, args.num_reqs/np, (args.num_reqs%np));
	MPI_Barrier(MPI_COMM_WORLD);

	args.num_reqs = num_reqs; 

	/* allocate requests and results for async reqs */
	reqs = (lwfs_request *)calloc(args.num_reqs, sizeof(lwfs_request));
	results = (data_t *)calloc(args.num_reqs, sizeof(data_t));


	/* initialize the data array */
	array.data_array_t_len = args.len; 
	array.data_array_t_val = (data_t *)malloc(args.len*sizeof(data_t));
	if (array.data_array_t_val == NULL) {
		log_error(xfer_debug_level, "out of space");
		return -1;
	}

	/* initialize the data */
	for (i=0; i<args.len; i++) {
		array.data_array_t_val[i].int_val = (int)i;
		array.data_array_t_val[i].float_val = (float)i;
		array.data_array_t_val[i].double_val = (double)i;
	}

	//fprintf(result_fp, "%s  len        nbytes     time (sec)    MB/sec \n", "%");
	//fprintf(result_fp, "%s ---------------------------------------------------\n", "%");


	/* loop over the exeriments (count == num_trials, num_reqs == ops_per_trial) */
    for (i=0; i<args.count; i++) {

		fprintf(stderr, "%d: trial=%d, reqs=%d, len=%d\n",
				myrank, i, args.num_reqs, args.len);

        switch (args.type) {

            case XFER_ARGS_BLK:
				start_time = lwfs_get_time();


                for (j=0; j<args.num_reqs; j++) {
                    rc = xfer_1_clnt_blk(&xfer_svc, &array, &result);
                    if (rc != LWFS_OK) {
                        log_error(xfer_debug_level, "could not transfer data: %s",
                                lwfs_err_str(rc));
                        goto cleanup;
                    }
                }

				time = lwfs_get_time() - start_time; 
                break;

            case XFER_ARGS_NOBLK:
				start_time = lwfs_get_time();

                /* submit requests */
                for (j=0; j<args.num_reqs; j++) {
                    rc = xfer_1_clnt(&xfer_svc, &array, &results[j], &reqs[j]);
                    if (rc != LWFS_OK) {
                        log_error(xfer_debug_level, "could not transfer data: %s",
                                lwfs_err_str(rc));
                        goto cleanup;
                    }
                }

                /* wait for results */
                rc = lwfs_waitall(reqs, args.num_reqs, -1); 
                if (rc != LWFS_OK) {
                    log_error(xfer_debug_level, "error transferring data");
                    goto cleanup; 
                }	

                /* store the average time for an async req */
				time = lwfs_get_time() - start_time; 
                break;

            case XFER_DATA_BLK:
				start_time = lwfs_get_time();

                /* submit requests */
                for (j=0; j<args.num_reqs; j++) {
                    rc = xfer_2_clnt_blk(&xfer_svc, &array, &result);
                    if (rc != LWFS_OK) {
                        log_error(xfer_debug_level, "could not transfer data: %s",
                                lwfs_err_str(rc));
                        goto cleanup;
                    }
                }

				time = lwfs_get_time() - start_time; 
                break;

            case XFER_DATA_NOBLK:
				start_time = lwfs_get_time();

                /* submit requests */
                for (j=0; j<args.num_reqs; j++) {
                    rc = xfer_2_clnt(&xfer_svc, &array, &results[j], &reqs[j]);
                    if (rc != LWFS_OK) {
                        log_error(xfer_debug_level, "could not transfer data: %s",
                                lwfs_err_str(rc));
                        goto cleanup;
                    }
                }

                /* wait for results */
                rc = lwfs_waitall(reqs, args.num_reqs, -1); 
                if (rc != LWFS_OK) {
                    log_error(xfer_debug_level, "error transferring data");
                    goto cleanup; 
                }	

                /* store the average time for an async req */
				time = lwfs_get_time() - start_time; 
                break;

            default:
                log_error(xfer_debug_level, "unrecognized experiment type");
                return -1;
        }

		MPI_Barrier(MPI_COMM_WORLD);
        output_stats(result_fp, &args, time);
    }


cleanup:

	free(array.data_array_t_val); 
	free(results);
	free(reqs); 
	fclose(result_fp);

	lwfs_rpc_fini();

	/* sizeof request header */
	fprintf(stderr, "sizeof(lwfs_request_header)=%lu\n", 
            (unsigned long)sizeof(lwfs_request_header));
	fprintf(stderr, "sizeof(lwfs_result_header)=%lu\n", 
            (unsigned long)sizeof(lwfs_result_header));

	exit (0);
}
