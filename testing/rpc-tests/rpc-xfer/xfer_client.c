/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <assert.h>
#include <math.h>
#include <argp.h>
#include <getopt.h>
#include <signal.h>
#include <unistd.h>
#include <time.h>
#include "xfer.h"

#include "support/timer/timer.h"


/* ----------------- COMMAND-LINE OPTIONS --------------- */

const char *argp_program_version = "$Revision: 1264 $"; 
const char *argp_program_bug_address = "<raoldfi@sandia.gov>"; 

static char doc[] = "Test the LWFS storage service";
static char args_doc[] = ""; 

/**
 * @brief Command line arguments for testing the storage service. 
 */
struct arguments {

	/** @brief the size of the input/output buffer to use for tests. */
	int len; 

	/** @brief The number of experiments to run. */
	int count; 

	/** @brief The number of requests sent to the server */
	int num_reqs; 

	int type; 

	/** @brief Hostname of the remote server. */
	char *server; 

	/** @brief Result file. */
	char *result_file; 

	/** @brief Result file mode. */
	char *result_file_mode; 
}; 


static int print_args(FILE *fp, const char *prefix, struct arguments *args) 
{
	time_t now; 

	/* get the current time */
	now = time(NULL);

	fprintf(fp, "%s -----------------------------------\n", prefix);
	fprintf(fp, "%s \tMeasure Sun RPC throughput\n", prefix);
	fprintf(fp, "%s \t%s", prefix, asctime(localtime(&now)));


	fprintf(fp, "%s ------------  ARGUMENTS -----------\n", prefix); 
	fprintf(fp, "%s \t--type = %d\n", prefix, args->type);
	fprintf(fp, "%s \t--len = %d\n", prefix, args->len);
	fprintf(fp, "%s \t--count = %d\n", prefix, args->count);
	fprintf(fp, "%s \t--num-reqs = %d\n", prefix, args->num_reqs);
	fprintf(fp, "%s \t--server = %s\n", prefix, args->server);
	fprintf(fp, "%s \t--result-file = %s\n", prefix, args->result_file);
	fprintf(fp, "%s \t--result-file-mode = %s\n", prefix, args->result_file_mode);
	fprintf(fp, "%s -----------------------------------\n", prefix);

	return 0;
}


static struct argp_option options[] = {
	{"server",    1000, "<server name>", 0, "name of the server"},
	{"len",    2000, "<val>", 0, "number of array elements to send for each exp"},
	{"count",      3000, "<val>", 0, "Number of experiments (trials) to run"},
	{"result-file",      4000, "<FILE>", 0, "Result file"},
	{"result-file-mode",      5000, "<val>", 0, "Result file mode"},
	{"type",      6000, "<val>", 0, "The type of experiments to run"},
	{"num-reqs",  7000, "<val>", 0, "The number of requests/trial"},
	{ 0 }
};

/** 
 * @brief Parse a command-line argument. 
 * 
 * This function is called by the argp library. 
 */
static error_t parse_opt(
		int key, 
		char *arg, 
		struct argp_state *state)
{
	/* get the input arguments from argp_parse, which points to 
	 * our arguments structure */
	struct arguments *arguments = state->input; 

	switch (key) {

		case 1000: /* host */
			arguments->server = arg;
			break;

		case 2000: /* len */
			arguments->len = atoi(arg);
			break;

		case 3000: /* count */
			arguments->count = atoi(arg);
			break;

		case 4000: /* count */
			arguments->result_file = arg;
			break;

		case 5000: /* count */
			arguments->result_file_mode = arg;
			break;

		case 6000: /* type */
			arguments->type = atoi(arg);
			break;

		case 7000: /* num_reqs */
			arguments->num_reqs = atoi(arg);
			break;


		case ARGP_KEY_ARG:
			/* we expect zero artuments one argument */
			if (state->arg_num >= 0) {
				argp_usage(state);
			}
			//arguments->args[state->arg_num] = arg; 
			//arguments->host = arg; 
			break; 

		case ARGP_KEY_END:
			if (state->arg_num < 0)
				argp_usage(state);
			break;

		default:
			return ARGP_ERR_UNKNOWN; 
	}

	return 0;
}

static struct argp argp = {options, parse_opt, args_doc, doc}; 

/*-----------------------------------------------------------*/


static void output_stats(
		FILE *result_fp,
		struct arguments *args,
		double t_total)
{
	double t_total_max = t_total;
	double t_total_min = t_total;
	double t_total_sum = t_total;
	int total_reqs = args->num_reqs;
	int myrank=0; 
	int np=1;
	static int first=1; 

	if (myrank == 0) {
		double t_total_avg = t_total_sum/np;
		double nbytes = total_reqs*(sizeof(int) + (args->len+1)*sizeof(data_t));

		if (first) {
			time_t rawtime;
			time(&rawtime);

			fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
			fprintf(result_fp, "%s rpc-xfer\n", "%");
			fprintf(result_fp, "%s %s", "%", ctime(&rawtime));
			fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
			fprintf(result_fp, "%s column   description\n", "%");
			fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
			fprintf(result_fp, "%s   0     number of clients\n", "%");
			fprintf(result_fp, "%s   1     total ops\n","%");
			fprintf(result_fp, "%s   2     data structures/op\n", "%");
			fprintf(result_fp, "%s   3     aggregate bytes\n","%");
			fprintf(result_fp, "%s   4     min time (sec)\n","%");
			fprintf(result_fp, "%s   5     max time (sec)\n","%");
			fprintf(result_fp, "%s   6     avg time (sec)\n","%");
			fprintf(result_fp, "%s   7     min throughput (MB/sec)\n","%");
			fprintf(result_fp, "%s   8     max throughput (MB/sec)\n","%");
			fprintf(result_fp, "%s   9     avg throughput (MB/sec)\n","%");
			fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
			first = 0; 
		}

		/* print the row */
		fprintf(result_fp, "%04d   ", np);    
		fprintf(result_fp, "%09d   ", total_reqs); 
		fprintf(result_fp, "%09d   ", args->len);    
		fprintf(result_fp, "%1.6e  ", nbytes); 
		fprintf(result_fp, "%1.6e  ", t_total_min); 
		fprintf(result_fp, "%1.6e  ", t_total_max); 
		fprintf(result_fp, "%1.6e  ", t_total_avg); 
		fprintf(result_fp, "%1.6e  ", nbytes/(t_total_max*1024*1024)); 
		fprintf(result_fp, "%1.6e  ", nbytes/(t_total_min*1024*1024)); 
		fprintf(result_fp, "%1.6e\n", nbytes/(t_total_avg*1024*1024)); 
		fprintf(result_fp, "%s ----------------------------------------------------\n", "%");
		fflush(result_fp);
	}
}




int
xfer_prog_1(FILE *result_fp, struct arguments *args)
{
	CLIENT *clnt;
	int i; 
	data_t  *result_1;
	data_array_t req;
	data_t *data; 

	clnt = clnt_create (args->server, XFER_PROG, XFER_VERS, "tcp");
	if (clnt == NULL) {
		clnt_pcreateerror (args->server);
		exit (1);
	}

	/* allocate the data buffer */
	data = (data_t *)malloc(args->len*sizeof(data_t)); 
	if (data == NULL) {
		fprintf(stderr, "out of memory\n");
		return -1; 
	}
	memset(data, 0, args->len*sizeof(data_t));


	/* initialize the data */
	for (i=0; i<args->len; i++) {
		data[i].int_val = (int)i;
		data[i].float_val = (float)i;
		data[i].double_val = (double)i;
	}

	memset(&req, 0, sizeof(data_array_t));
	req.data_array_t_len = args->len; 
	req.data_array_t_val = data; 

	/* call once to warm caches */
	for (i=0; i<args->num_reqs; i++) {
		/* call the remote function */
		result_1 = data_xfer_1(&req, clnt);
		if (result_1 == (data_t *) NULL) {
			clnt_perror (clnt, "call failed");
		}
	}

	/* time this set of experiments */
	for (i=0; i<args->count; i++) {
		int j; 
		double start, time; 

		start = lwfs_get_time(); 

		/* call the remote function */
		for (j=0; j<args->num_reqs; j++) {
			result_1 = data_xfer_1(&req, clnt);
			if (result_1 == (data_t *) NULL) {
				clnt_perror (clnt, "call failed");
			}
		}

		time = lwfs_get_time() - start; 

		output_stats(result_fp, args, time); 
	}


	clnt_destroy (clnt);

	free(data);

	return 0;
}

int
xfer_prog_2(FILE *result_fp, struct arguments *args)
{
	CLIENT *clnt;
	int i; 
	char *result_1;
	buf_array_t req;
	buf_t *data; 

	clnt = clnt_create (args->server, XFER_PROG, XFER_VERS, "tcp");
	if (clnt == NULL) {
		clnt_pcreateerror (args->server);
		exit (1);
	}

	/* allocate the data buffer */
	data = (buf_t *)malloc(args->len*sizeof(buf_t)); 
	if (data == NULL) {
		fprintf(stderr, "out of memory\n");
		return -1; 
	}
	memset(data, 0, args->len*sizeof(buf_t));


	/* initialize the data */
	for (i=0; i<args->len; i++) {
		data_t *d = (data_t *)&data[i];
		d->int_val = (int)i;
		d->float_val = (float)i;
		d->double_val = (double)i;
	}

	memset(&req, 0, sizeof(buf_array_t));
	req.buf_array_t_len = args->len; 
	req.buf_array_t_val = data; 

	/* call once to warm caches */
	for (i=0; i<args->num_reqs; i++) {
		/* call the remote function */
		result_1 = buf_xfer_1(&req, clnt);
		if (result_1 == NULL) {
			clnt_perror (clnt, "call failed");
		}
	}

	/* time this set of experiments */
	for (i=0; i<args->count; i++) {
		int j; 
		double start, time; 

		start = lwfs_get_time(); 

		/* call the remote function */
		for (j=0; j<args->num_reqs; j++) {
			result_1 = buf_xfer_1(&req, clnt);
			if (result_1 == NULL) {
				clnt_perror (clnt, "call failed");
			}
		}

		time = lwfs_get_time() - start; 

		output_stats(result_fp, args, time); 
	}

	clnt_destroy (clnt);

	free(data);

	return 0;
}


int
main (int argc, char *argv[])
{
	struct arguments args; 

	FILE *result_fp = stdout;

	/* default values for the arguments */
	args.type = 0;
	args.count = 1; 
	args.len = 1;
	args.num_reqs = 1; 
	args.server = "localhost";
	args.result_file = NULL;
	args.result_file_mode = "w"; 

	argp_parse(&argp, argc, argv, 0, 0, &args); 

	if (args.result_file != NULL) {
		result_fp = fopen(args.result_file, args.result_file_mode);
		if (result_fp == NULL) {
			fprintf(stderr, "could not open %s: using stdout\n",
				args.result_file);
			result_fp = stdout; 
		}
	}

	print_args(result_fp, "%", &args); 

	switch (args.type) {
		case 0:
			xfer_prog_1 (result_fp, &args);
			break;

		case 1:
			xfer_prog_2 (result_fp, &args);
			break;

		default:
			fprintf(stderr, "invalid type\n");
			return -1;
	}

	exit (0);
}
